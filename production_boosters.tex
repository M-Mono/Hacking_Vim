% vim: ts=4 sts=4 sw=4 et tw=80
\chapter{效率推进器}
\label{chap:production_boosters}

\marginpar{73}
在这一章, 我们将会看到, 即使是一些小小的改动, 也可以地促进 Vim 的工作效率. 有些
技巧是由 Vim 的特性提供的, 另外一些则需要用户自已编写一些脚本.

无论你把 Vim 当成一个修改配置文件的小工具, 还是把它用作某个大型开发项目的主要
编辑器, 你都可以发现本章介绍的方法可以极大地促进使用 Vim 的使用效率.

这一章讨论的主题包括:
\begin{itemize}
    \item 使用模版文件的模式
    \item 使用缩写的模版
    \item 使用已知单词与 tag list 的自动补全
    \item 使用 omnicompletion 的自动补全
    \item 宏与宏录制
    \item 使用会话
    \item 使用会话的项目管理
    \item 寄存器与撤消分支
    \item 折叠
    \item 使用 \texttt{vimdiff} 分析差异
    \item 使用 \texttt{netrw} 来随时随地地打开文件
\end{itemize}

阅读完这一章之后, 用户使用 Vim 的工作效率应该可以提高好几个百分点.
\marginpar{74}

\section{使用模版}
\label{sec:using_templates}

无论编辑的是哪一种类型的文件, 当打开一个新文件时, 总有一些基础性的工作需要完成.
手动完成这些基础工作是一件非常乏味的事件, 更讨厌的是每次打开一个新文件时, 都
要重新再做一遍. 所以说干嘛要花这么多的时间, 来做一件使用模版就可以完成的事情?

在接下来的两节, 我们将会看到一些不同类型的模版. 其中一些模版特定于文件类型, 另
外一些则会使用用户的输入来触发小内容模版 (比如, 程序员经常用到的代码片断).

\subsection{使用模版文件}
\label{subsec:using_template_files}

每次打开一个新文件时, 用户做的第一件事经常是输入某些头部信息, 当然, 所要输入的
信息取决于文件的类型. 比较常见的例子包括:
\begin{itemize}
    \item 在新的 HTML 文件中添加基本结构 (\texttt{<html>}, \texttt{<head>},
        \texttt{<body>}).
    \item 在所有的 C 文件添加头部信息, 在文件 \texttt{main.c} 中添加
        \texttt{main()} 函数.
    \item 在 Java 文件中添加主类.
\end{itemize}
除了这些, 你应该还能想到其他一些例子.

那么, 我们怎么才能创建一个模版文件? 不妨让我们用 HTML 文件作为例子来进行讲解.
这种文件的结构是静态的, 因此非常适合用模版来处理. HTML 模版的内容是:
\begin{vimcmd}
<html>
    <head>
        <title></title>
            <meta name="generator" content="Vim" />
            <meta name="author" content="Kim Schulz" />
    </head>
    <body>
        <p>Content goes here...</p>
    </body>
</html>
\end{vimcmd}
我们在 \texttt{VIMHOME} 目录下创建一个新目录 \texttt{templates/}, 并把上面的
模版文件保存到这个目录中, 假设我们把模版文件命令为 \texttt{html.tpl}.
\marginpar{75}
现在, 第一个模版已经准备就绪, 不过, 当我们创建一个新的 HTML 文件时, 需要加载
模版文件, 为了完成加载, 把下面这行命令添加到 \texttt{vimrc} 中:
\begin{vimcmd}
:autocmd BufNewFile *.html 0r $VIMHOME/templates/html.tpl
\end{vimcmd}
这个命令可以确保当我们新建一个 \texttt{*.html} 文件时, 模版文件的内容会自动加
载到新文件中. 于是, 当我们开始编辑新文件前, 文件中就已经包含了模版的内容.

本来这样做没什么问题, 但是当添加的模版文件越来越多时, 我们可能会越来越讨厌每
次都要往 \texttt{vimrc} 中添加一行加载命令. 所以, 让我们把加载模版的命令写得
更灵活一点:
\begin{vimcmd}
:autocmd BufNewFile * silent! 0r $VIMHOME/templates/%:e.tpl
\end{vimcmd}
命令的功能是: 无论何时打开一个新文件, Vim 就在模版目录中搜索以文件扩展名命名
的模版. 比如, 创建一个 \texttt{index.html} 文件时, Vim 就在
\texttt{\$VIMHOME/templates/} 中搜索名为 \texttt{html.tpl} 的模版文件.

如果没有找到指定的模版, Vim 就创建一个空文件.

让我们把模版写得更完善一点: 添加对占位符 (占位符指的是你将要添加文本的地方) 的
支持. 一个占位符看起来可以非常得与众不同, 这取决于你, 笔者通常把它们显示成类似
于 \texttt{<+KERWORD+>} 的形式. 如果我们在前面的 HTML 模版中添加上占位符,
模版的内容就变成了:
\begin{vimcmd}
<html>
    <head>
        <title><+TITLE+></title>
            <meta name="generator" content="<+GENERATOR+>" />
            <meta name="author" content="<+AUTHOR+>" />
    </head>
    <body>
        <p><+CONTENT+></p>
    </body>
</html>
\end{vimcmd}

现在, 我们已经准备好的占位符, 接下为的工作就是在占位符之间跳转. 为了让跳转更加
方便, 我们把跳转命令添加到 \texttt{vimrc} 中. 我们想要把组合键 \key{Ctrl+j}
映射到跳转命令, 因为这样做的话便于在插入模式下使用, 组合键中 \texttt{j} (意
指 jump) 也更容易记忆. 映射组合键的命令是:
\begin{vimcmd}
nnoremap <c-j> /<+.\{-1,}+><cr>c/+>/e<cr>
inoremap <c-j> <ESC>/<+.\{-1,}+><cr>c/+>/e<cr>
\end{vimcmd}
\marginpar{76}
现在, 只需要按下组合键 \key{Ctrl+j}, 你就可以方便地跳转到文件中的下一个占位符,
输入文本, 然后再跳转到下一个占位符.

通过在占位符中添加关键字, 就可以提醒用户应该在占位符中输入什么样的内容.

\begin{warning}
可以通过命令 \texttt{match} 高亮显示占位符, 具体的设置命令是: \texttt{match
Todo /<+.\++>/}, 把这行命令添加到 \texttt{vimrc} 中 (可以把命令中的
\texttt{Todo} 替换成任意一种你喜欢的色彩组.
\end{warning}

\subsection{把缩写作为模版}
\label{subsec:abbreviations_as_templates}

在前面的小节里, 我们学习了如何为不同类型的文件制作模版. 那么, 现在就来介绍一下
如何为文件的内容制作模版.

在第 \ref{chap:personalizing_vim} 章, 我们简单地介绍了如何通过缩写来减少击键的
次数, 现在我们就把缩写应用到模版中. 回忆一下下面这个命令的作用:
\begin{vimcmd}
:iabbrev match replace-string
\end{vimcmd}
我们只想让上面的命令工作在插入模式, 这是因为模式模版本来就应该工作在插入模式下.
对于 C 文件来说, 一个常见的例子是:
\begin{vimcmd}
:iabbrev <buffer> for( for (x=0;x<var;x++){<cr><cr>}
\end{vimcmd}
无论我们在什么时候输入文本 \texttt{for(}, Vim 都会自动插入一段 \texttt{for} 循
环. \texttt{(} 可以防止手工输入的 \texttt{for} 循环被自动转换. 插入的内容看起
来就像:
\begin{vimcmd}
for (x=0;x<var;x++){

}
\end{vimcmd}

\begin{warning}
    缩写词左边的 \texttt{<buffer>} 限制了命令的作用范围仅限于当前缓冲区.
\end{warning}

正如你所看到的那样, 生成的代码模版是静态的. 为了让模版更灵活一点, 把前面一节介
绍占位符应用进来.
\marginpar{77}
