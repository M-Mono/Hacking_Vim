% vim: ts=4 sts=4 sw=4 et tw=80
\chapter{效率推进器}
\label{chap:production_boosters}

\marginpar{73}
在这一章, 我们将会看到, 即使是一些小小的改动, 也可以地促进 Vim 的工作效率. 有些
技巧是由 Vim 的特性提供的, 另外一些则需要用户自已编写一些脚本.

无论你把 Vim 当成一个修改配置文件的小工具, 还是把它用作某个大型开发项目的主要
编辑器, 你都可以发现本章介绍的方法可以极大地促进使用 Vim 的使用效率.

这一章讨论的主题包括:
\begin{itemize}
    \item 使用模版文件的模式
    \item 使用缩写的模版
    \item 使用已知单词与 tag list 的自动补全
    \item 使用 omnicompletion 的自动补全
    \item 宏与宏录制
    \item 使用会话
    \item 使用会话的项目管理
    \item 寄存器与撤消分支
    \item 折叠
    \item 使用 \texttt{vimdiff} 分析差异
    \item 使用 \texttt{netrw} 来随时随地地打开文件
\end{itemize}

阅读完这一章之后, 用户使用 Vim 的工作效率应该可以提高好几个百分点.
\marginpar{74}

\section{使用模版}
\label{sec:using_templates}

无论编辑的是哪一种类型的文件, 当打开一个新文件时, 总有一些基础性的工作需要完成.
手动完成这些基础工作是一件非常乏味的事件, 更讨厌的是每次打开一个新文件时, 都
要重新再做一遍. 所以说干嘛要花这么多的时间, 来做一件使用模版就可以完成的事情?

在接下来的两节, 我们将会看到一些不同类型的模版. 其中一些模版特定于文件类型, 另
外一些则会使用用户的输入来触发小内容模版 (比如, 程序员经常用到的代码片断).

\subsection{使用模版文件}
\label{subsec:using_template_files}

每次打开一个新文件时, 用户做的第一件事经常是输入某些头部信息, 当然, 所要输入的
信息取决于文件的类型. 比较常见的例子包括:
\begin{itemize}
    \item 在新的 HTML 文件中添加基本结构 (\texttt{<html>}, \texttt{<head>},
        \texttt{<body>}).
    \item 在所有的 C 文件添加头部信息, 在文件 \texttt{main.c} 中添加
        \texttt{main()} 函数.
    \item 在 Java 文件中添加主类.
\end{itemize}
除了这些, 你应该还能想到其他一些例子.

那么, 我们怎么才能创建一个模版文件? 不妨让我们用 HTML 文件作为例子来进行讲解.
这种文件的结构是静态的, 因此非常适合用模版来处理. HTML 模版的内容是:
\begin{vimcmd}
<html>
    <head>
        <title></title>
            <meta name="generator" content="Vim" />
            <meta name="author" content="Kim Schulz" />
    </head>
    <body>
        <p>Content goes here...</p>
    </body>
</html>
\end{vimcmd}
我们在 \texttt{VIMHOME} 目录下创建一个新目录 \texttt{templates/}, 并把上面的
模版文件保存到这个目录中, 假设我们把模版文件命令为 \texttt{html.tpl}.
\marginpar{75}
现在, 第一个模版已经准备就绪, 不过, 当我们创建一个新的 HTML 文件时, 需要加载
模版文件, 为了完成加载, 把下面这行命令添加到 \texttt{vimrc} 中:
\begin{vimcmd}
:autocmd BufNewFile *.html 0r $VIMHOME/templates/html.tpl
\end{vimcmd}
这个命令可以确保当我们新建一个 \texttt{*.html} 文件时, 模版文件的内容会自动加
载到新文件中. 于是, 当我们开始编辑新文件前, 文件中就已经包含了模版的内容.

本来这样做没什么问题, 但是当添加的模版文件越来越多时, 我们可能会越来越讨厌每
次都要往 \texttt{vimrc} 中添加一行加载命令. 所以, 让我们把加载模版的命令写得
更灵活一点:
\begin{vimcmd}
:autocmd BufNewFile * silent! 0r $VIMHOME/templates/%:e.tpl
\end{vimcmd}
命令的功能是: 无论何时打开一个新文件, Vim 就在模版目录中搜索以文件扩展名命名
的模版. 比如, 创建一个 \texttt{index.html} 文件时, Vim 就在
\texttt{\$VIMHOME/templates/} 中搜索名为 \texttt{html.tpl} 的模版文件.

如果没有找到指定的模版, Vim 就创建一个空文件.

让我们把模版写得更完善一点: 添加对占位符 (占位符指的是你将要添加文本的地方) 的
支持. 一个占位符看起来可以非常得与众不同, 这取决于你, 笔者通常把它们显示成类似
于 \texttt{<+KERWORD+>} 的形式. 如果我们在前面的 HTML 模版中添加上占位符,
模版的内容就变成了:
\begin{vimcmd}
<html>
    <head>
        <title><+TITLE+></title>
            <meta name="generator" content="<+GENERATOR+>" />
            <meta name="author" content="<+AUTHOR+>" />
    </head>
    <body>
        <p><+CONTENT+></p>
    </body>
</html>
\end{vimcmd}

现在, 我们已经准备好的占位符, 接下为的工作就是在占位符之间跳转. 为了让跳转更加
方便, 我们把跳转命令添加到 \texttt{vimrc} 中. 我们想要把组合键 \key{Ctrl+j}
映射到跳转命令, 因为这样做的话便于在插入模式下使用, 组合键中 \texttt{j} (意
指 jump) 也更容易记忆. 映射组合键的命令是:
\begin{vimcmd}
nnoremap <c-j> /<+.\{-1,}+><cr>c/+>/e<cr>
inoremap <c-j> <ESC>/<+.\{-1,}+><cr>c/+>/e<cr>
\end{vimcmd}
\marginpar{76}
现在, 只需要按下组合键 \key{Ctrl+j}, 你就可以方便地跳转到文件中的下一个占位符,
输入文本, 然后再跳转到下一个占位符.

通过在占位符中添加关键字, 就可以提醒用户应该在占位符中输入什么样的内容.

\begin{warning}
可以通过命令 \texttt{match} 高亮显示占位符, 具体的设置命令是:
\verb'match Todo /<+.\++>/', 把这行命令添加到 \texttt{vimrc} 中 (可以把命令中的
\texttt{Todo} 替换成任意一种你喜欢的色彩组.
\end{warning}

\subsection{把缩写作为模版}
\label{subsec:abbreviations_as_templates}

在前面的小节里, 我们学习了如何为不同类型的文件制作模版. 那么, 现在就来介绍一下
如何为文件的内容制作模版.

在第 \ref{chap:personalizing_vim} 章, 我们简单地介绍了如何通过缩写来减少击键的
次数, 现在我们就把缩写应用到模版中. 回忆一下下面这个命令的作用:
\begin{vimcmd}
:iabbrev match replace-string
\end{vimcmd}
我们只想让上面的命令工作在插入模式, 这是因为模式模版本来就应该工作在插入模式下.
对于 C 文件来说, 一个常见的例子是:
\begin{vimcmd}
:iabbrev <buffer> for( for (x=0;x<var;x++){<cr><cr>}
\end{vimcmd}
无论我们在什么时候输入文本 \texttt{for(}, Vim 都会自动插入一段 \texttt{for} 循
环. \texttt{(} 可以防止手工输入的 \texttt{for} 循环被自动转换. 插入的内容看起
来就像:
\begin{vimcmd}
for (x=0;x<var;x++){

}
\end{vimcmd}

\begin{warning}
    缩写词左边的 \texttt{<buffer>} 限制了命令的作用范围仅限于当前缓冲区.
\end{warning}

正如你所看到的那样, 生成的代码模版是静态的. 为了让模版更灵活一点, 把前面一节介
绍占位符应用进来.
\marginpar{77}
在这种情景下使用的占位符更像是一个跳转点, 因为我们把它们简化成 \texttt{<+++>}.
除此之外, 在插入模式模版之后, 我们需要在光标的下一个位置上放置一个占位符, 对于
前面的例子来说, 光标的下一个位置应该是左括号的右边.

为了实现这个目标, 我们引入 \texttt{!cursor!} 占位符, 命令的内容是:
\begin{vimcmd}
iabbrev for( for(!cursor!;<+++>;<+++>){<cr><+++><cr>}<Esc>
    :call search('!cursor!','b')<cr>cf!:
\end{vimcmd}
(上面的命令都在同一行上)

现在, 无论何时输入 \texttt{for(}, Vim 都会自动插入一段 \texttt{for} 循环, 然后 
把光标移动到占位符 \texttt{!cursor!} (当光标移过来时, 占位符上原来的内容会自动
被移除). 接下来, 你就可以方便地填写 \texttt{for} 循环的参数, 并用 \key{Ctrl+j}
跳转到下一个参数的位置.

也许你已经知道, 许多编程语言都有相同的主要结构 (比如 \texttt{for} 循环), 但是 
它们之间的差异导致了无法使用同一个模式模版. 让我们回过头来看一下手上已有的东西,
看看是否可以让它们识别文件类型.

在前面的一节里, 我们介绍了如何根据文件的扩展名来加载相应的模版文件, 具体的命令
是:
\begin{vimcmd}
:autocmd BufNewFile * silent! 0r $VIMHOME/templates/%:e.tpl
\end{vimcmd}
让我们对这个命令进行修改, 使得 Vim 可以根据文件的类型, 为我们的模式版本自动加
载适当的缩写.

为了能让命令更聪明一点, 我们把命令的功能用函数来实现. 函数的代码是:
\begin{vimcmd}
function! LoadTemplate(extension)
    silent! :execute '0r $VIMHOME/templates/'. a:extension. '.tpl'
    silent! execute 'source $VIMHOME/templates/'.a:extension.'.patterns.tpl'
endfunction
\end{vimcmd}
为了调用函数, 我们把 \texttt{autocmd} 修改成:
\begin{vimcmd}
:autocmd BufNewFile * silent! call LoadTemplate('%:e')
\end{vimcmd}
函数 \texttt{LoadTemplate} 在 \texttt{\$VIMHOME} 的 \texttt{templates} 子目录
下搜索两个文件: \texttt{EXTENSION.tpl} 与 \texttt{EXTENSION.patterns.tpl}.
其中 \texttt{EXTENSION} 表示当前打开的文件的扩展名.
\marginpar{78}
第 1 个文件包含了特定文件类型的模版, 而第 2 个文件则包含了特定文件类型的缩写
命令. 如果没有找到对应的文件, 那么命令 \texttt{silent!} 就会抑制错误信息的显
示, 而仅仅是什么都没有返回.

现在, 模版文件中该包含什么样的内容完全由用户来决定.

\begin{warning}
    已经有人为 Vim 编写了大量的模版系统脚本, 其中大部分都是以本章介绍的概念为基础,
    但是增加了许多额外的功能. 除了这里介绍的之外, 如何用户还想要更多的模版选项,
    笔者推荐你看一下由 Gergely Kontra 编写的 mu-template, 可以到下面这
    个网址下载: \url{http://www.vim.org/scripts/script.php?script_id=222}.
\end{warning}

\subsection{snipMate 脚本}
\label{subsec:snippets_with_the_snipmate_script}

虽然已经有大量的模版系统脚本可供使用, 而且它们中的大部分都是以本章介绍的概念
为基础, 但是有时候对于特定的文件格式, Vim 还是没有提供足够的支持. 对于这些情况,
用户可以使用 snippet 脚本. Snippet 和用在模版中的缩写有点类似, 但是要更高级一
点.

如果你想在 Vim 中使用 snippet, 笔者推荐你看一下 snipMate 脚本, 下载地址是
\url{http://www.vim.org/scripts/script.php?script_id=2540}.

snipMate 可以让用户在不需要了解 Vim 脚本的前提下, 为自己的文件格式定义高级的
snippet.

假设用户想为 \texttt{for} 循环创建一个 snippet (在前面的一节里我们用的是 
\texttt{iabbrev}),  那就这样做:
\begin{vimcmd}
snippet for
    for (${1:i} = 0; $1 < ${2:count}; $1${3:++}) {
        ${4:/* code */}
    }
\end{vimcmd}
把上面这段文本写到一个文件中, 再把这个文件放到 \texttt{\$VIMHOME/snippets} 目
录下, 把文件命名为 \texttt{FILETYPE.snippet} (\texttt{FILETYPE} 表示文件类型,
比如 C 代码就是 \texttt{c}, PHP 代码就是 \texttt{php}).
\marginpar{79}
