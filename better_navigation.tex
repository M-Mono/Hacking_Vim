% vim: ts=4 sts=4 sw=4 et tw=80
\chapter{更好的导航}
\label{chap:better_navigation}
\marginpar{53}
同时应付多个文件可能是一件非常麻烦的事, 有时候, 用户可能会花更多的时间来
定位文件, 而不是编辑.

Vim 的处事哲学是不浪费用户的宝贵时间, 所以它提供了许多用于定位文件的方法.

在这一章, 我们将会学习到 Vim 如何帮助我们在多个文件中导航, 无论此时是在
处理 1 个文件, 还是 50 个文件. 其中的某些方法使用标记, 以便于稍后返回到该
区域, 还有些方法使用搜索来定位目标.

这一章包含的内容有:
\begin{itemize}
    \item 在单个文件中更快地导航
    \item 在 Vim 帮助系统中更快地导航
    \item 在多个缓冲区更快地导航
    \item 使用 Vim 文件浏览器, 以便更快地搜索文件
    \item 文件内搜索
    \item 使用 \texttt{vimgrep} 在多个文件或多个缓冲区中搜索
    \item 使用标记作为导航的工具
    \item 使用符号来得到更好的概览
\end{itemize}

学习后这一章之后, 用户的导航速度将会有质的提升, 在搜索文件时也不会再遇到
什么问题.
\marginpar{54}
\section{在文件内更快地导航}
\label{sec:faster_navigation_in_a_file}

有时候, 即使是一件最简单的工作 --- 比如在一个单独的文件中导航 --- 也有优化
的空间. Vim 提供了几种在文件内导航的方法, 这些方法可以根据文件的内容和组织
结构而加以调整. 其中有些方法非常简单, 而另外一些则比较复杂.

\subsection{基于上下文的导航}
\label{subsec:context_aware_navigation}

在大部分情况下, 正在编辑的文件是有结构的. 如果是普通的文本文件, 那么文件的结
构可以是段落, 语句, 单词, 在另外的一些场合中, 还有可能是函数, 代码块和代码
行.

Vim 支持根据文件的结构, 在文件中跳转. 它还提供了一些按键绑定, 从而可以更
方便地跳转到某个特定的位置.

让我们来看一些例子:
\begin{itemize}
    \item 在普通的文本文件中移动
    \item 在代码文件中移动
\end{itemize}

\subsubsection{在普通的文本文件中移动}
\label{subsubsec:moving_around_within_a_text_file}

假设用户正在编辑一个普通文件文件, 此时光标正停留在一个句子的中部, 而用户
突然意识到自己忘了把本段的第一个字母大写. 虽然用户可以通过方向键, 或
\key{h}, \key{j}, \key{k}, \key{l}, 把光标移到段落的首字母. 然而, 在普通 
模式下, 直接按下面这个按键可以得到更好的效果:
\begin{vimcmd}
{
\end{vimcmd}

按完这个按键之后, 光标已经停在了段落的开头, 或者是段落正上方的空行 (如果 
有的话). 现在, 用户可以通过按下 \key{Esc} 进入到普通模式, 再按 \key{\{},
把光标移到段落的开始. 与此类似, 用户只要按下和 \key{\{} 相对的按键, 即:
\begin{vimcmd}
}
\end{vimcmd}
就可以把光标移到段落的末尾.

也许用户并不是在段落的末尾工作, 而是在修改段落中的某些错误. Vim 可以记住
用户之前修改过的地方 (实际上, Vim 可以记住最近 999 个被修改过的地方), 因此
用户可以通过询问这些信息, 从而回到正确的地点. 在普通模式下执行下面这个命令:
\begin{vimcmd}
g,
\end{vimcmd}
\marginpar{55}
执行该命令几次, 就可以遍历之前修改过的地方. 和 \key{\{} 一样, 它也有一个相反
的命令, 用于反向遍历之前修改过的地方, 这个命令是
\begin{vimcmd}
g;
\end{vimcmd}
如果没有更多的地方可供遍历, Vim 就会发出一个警告.

还有一种情况是, 用户并不是在段落的开头忘记了大写字母, 而是在句子的开头, 对此,
Vim 也提供了一对命令, 用来把光标移到句子的开始与末尾, 这对命令是:
\begin{itemize}
    \item \key{(}: 移到句子的开头
    \item \key{)}: 移到句子的末尾
\end{itemize}

Vim 不希望用户在移动光标上花费太多的时间, 虽然用户可以通过方向键来遍历字母, 从
而在单词间移动, 但是 Vim 还是认为这太浪费按键了. Vim 提供了一组命令, 用于在单词
间移动, 比如:
\begin{itemize}
    \item \key{w}: 移到下一个单词的首字母
    \item \key{b}: 移到前一个单词的首字母
    \item \key{e}: 移到单词的末尾
\end{itemize}
这些命令可以互相组合, 比如, 用户想要移到下一个单词的末尾, 只需要执行:
\begin{vimcmd}
we
\end{vimcmd}

对于单词的定义, Vim 有两套标准:
\begin{itemize}
    \item 一个 word 由字母, 数字, 破折号, 下划线组成
    \item 一个 WORD 由非空白字符 (除了制表符与空格) 组成
\end{itemize}
前面提到的命令用于 word, 当然, WORD 也会有相应的命令, 只不过使用的是大写形式
(比如用 \key{W} 移到下一个 WORD 的首字母).
\marginpar{56}
\begin{warning}
    如果读者希望在一行内多次执行本小节中提到的命令, 只需要在执行命令前加上一个
    数字即可, 这个数字表示命令执行的次数. 例如, \texttt{5w} 表示光标向前移动 5
    个单词.
\end{warning}

\subsubsection{在代码文件中移动}
\label{subsubsec:moving_in_a_code_file}

和普通文本文件相比, 代码文件并没有段落或句子上的概念, 它包含的是大量的结构和块,
其中每一个结构或块都有特定的上下文含义. 一个简单的例子是:
\begin{verbatim}
    if (a == b)
    {
        print "a and b are the same"
    }
\end{verbatim}
代码中, 带有 \texttt{print} 的行在 \texttt{if} 块的上下文环境中.

因为 Vim 深受众多程序员的喜爱, 所以它提供了许多在代码中移动的命令. Common for
all of them is that the parts of the code you want to jump between need to have
a contextual connection to each other.\footnote{TODO}

一个简单的例子可以是 C 语言中的 \texttt{\#if}-\texttt{\#else}-\texttt{\#endif}
代码块, 这三个元素分别处于代码块的开始, 中间, 和结束.

如果用户此时正位于 \texttt{\#if} 所在的行, 按下命令:
\begin{vimcmd}
%
\end{vimcmd}
就可以跳转到 \texttt{\#else} 所在的行, 此时再按一次 \verb'%', 又会跳转到
\texttt{\#endif} 所在的行, 再按一次 \verb'%' 就会回到最初的 \texttt{\#if}.

Vim 无法识别所有的编程语言的构造, 不过在默认情况下, 它可以识别 C 语言的大部分
结构. 除此之外, 它还可以识别出大部分编程语言的普通代码块 --- 代码块通过圆括号
与花括号定界 (例如, \verb'{' 标出了块的开始, 而 \verb'}' 则表示块的结束).
\marginpar{57}
\begin{warning}
    如果用户希望 Vim 能够识别其他更多语言的构造, 可以通过安装插件
    \texttt{matchit}\footnote{原文是 \texttt{mtchit} --- 译者} 来实现, Vim 7.0
    以上的版本已经安装了该插件, 不过也可以到 \url{http://www.vim.org/scripts/}
    上获取.
\end{warning}

通过对程序员如何使用圆括号/花括号的简单了解, Vim 向我们提供了几个有用的导航命令.
也就是说, 只要代码使用了圆括号/花括号来标记一个块的开始, 并且使用相应的结束符号
来标记块的结束, Vim 就能识别该代码块.

假设用户现在正在某个函数内, 这个函数包含多行代码, 而用户想要跳转到函数的开头.
在大部分情况下, 包围函数体的花括号是光标当前所在位置的最外层的花括号 (假设用户
正在编写该函数). 于是, 对 Vim 来说, 为了跳转到函数的开头, 只需要找到最外层的那
对花括号, 然后再跳到开括号即可.
\begin{verbatim}
    function myExample() {
        ...many lines of code...
        /* cursor is placed at the beginning of this line */
        ...many lines of code...
    }
\end{verbatim}
在上面的例子中, 命令 \verb'%' 把光标移动到闭括号, 再按一次 \verb'%' 就可以跳到
开括号. 但是, 如果此时光标正处于另一对花括号的内部, 又该如何? 在这种情况下, 命
令 \verb'%' 只能让光标在这对花括号之间移动, 而无法移动到函数的开头.

Vim 还提供了其他一些方便的命令:
\begin{itemize}
    \item \texttt{[[} 与  \texttt{][}: 向后/向前移动到下一节的开头 (比如函数的开
        头)
    \item \texttt{[]} 与  \texttt{]]}: 向后/向前移动到下一节的结束 (比如函数的末
        尾)
\end{itemize}
多次执行这些命令可以让光标移动到 下一节/上一节 的 开头/结束, 这样的话, 循环遍历
文件中的函数就方便多了.

如果文件中含有两个或更多的函数, 而此时光标位于第 1 个函数的开头, 按下 \texttt{[}
两次可以把光标移动到下一个函数的开头, 以此类推. 如果想要回到前一个函数中, 只需要
按下 \texttt{]]}, 光标就回到了前一个函数的开头.
\marginpar{58}
\begin{warning}
    需要注意的是, 在大部分的面向对象语言中, 类的开头与结束通常是最外层的部分.
\end{warning}

很多时候, 用户只是想要跳转到当前块的起始处 (例如, \texttt{while} 循环的开始),
因此块内的局部变量都定义在此处, 对于这个需求, Vim 也有对应的一套命令:
\begin{itemize}
    \item \verb'[{': 跳转到块的开始
    \item \verb']}': 跳转到块的结束
\end{itemize}

如果是注释块, 则不会被括号所包围, 因此 Vim 也就无法利用括号来跳转到块的开始或结
束.

为了处理注释块, Vim 提供了一些特殊的移动命令:
\begin{vimcmd}
    \item \verb'[/': 跳转到注释块的开始
    \item \verb']/': 跳转到注释块的结束
\end{vimcmd}

在默认的情况下, Vim 并不支持所有可能的注释格式, 它支持的注释格式主要是 C 语言 
(\verb'/* */'), C++ (\verb'//'), 和大多数的脚本语言 (\verb'#'). 然而, 如果用户 
想要添加对新语言语法的支持, 那么让 Vim 支持它的注释格式也是可以办到的.

有时候, 当用户在编写某小段代码时, 很有可能会忘记某个变量最初是如何定义的. Vim 
提供了一个用于查看变量定义 (或变量第一次出现的地方, 如果是解释型语言 --- 比如
Python --- 就可能有这个需求) 的命令, 不过前提是变量是在当前文件内定义的. 当光标
位于变量名上时, 按下下面这个命令, 就可以跳到变量的声明位置:
\begin{vimcmd}
gd
\end{vimcmd}
这个变量非常容易记忆, 它可以看成 ``Goto Declaration'' 的缩写形式.

当执行这个命令时, Vim 所做的操作是跳到当前区段的开始 (回忆命令 \verb'[['), 因为
因为这里是定义局部变量的通常位置, 然后, Vim 在文件中向前搜索变量名第一次出现的
地方. 如果在到达搜索开始的地点时还没有找到, 那就跳到文件的第 1 行, 再向前搜索变
量的全局定义. 如果还是没有找到, Vim 就会在文件内执行 \verb'*' 搜索 (更多的关于
\verb'*' 搜索的内容可以参考 \ref{sec:search_and_you_will_find} 节).
\marginpar{59}

如果用户已经知道变量是在全局定义的, 又或者是想要查找变量的全局定义, 那么可以使
用 Vim 的一个命令, 该命令从文件的第 1 行开始查找, 而不是在当前区段内查找. 这个 
命令是:
\begin{vimcmd}
gD
\end{vimcmd}
Vim 非常联盟, 它会自动忽略注释块中的变量引用, 因为这里绝不可能出现变量的声明.

如果 Vim 找到了变量的定义 (或者是该变量在文件内的第一次使用\footnote{原文是 
or the first available usage of the variable in the file}), 那么光标就会跳转到
该位置.

\begin{tips}
    在执行 \texttt{gd} 之前输入一个 \texttt{1} (即 \texttt{1gd}), 就可以让 Vim 
    忽略被 \verb'{}' 包围的代码块的匹配, 而该代码块出现在当前的光标位置之前
    (例如, 在文件早先位置定义的另一个函数).
\end{tips}

\subsection{在长行内导航}
\label{subsec:navigating_long_lines}

有些人喜欢回绕显示过长的行, 而有些人则希望单行显示, 即使过长的行会跑到边办之外.
从我个人来说, 我更倾向于回绕显示, 因此可以更方便地看到文本的全貌. 不过这有时会
让人感到很讨厌. 如果用户面对着一个回绕的长行, 那么回绕的部分在视觉效果上就像新
的一行那样显示. 这本来并没有问题, 但是如果在这种回绕的长行内移动光标 --- 比如 
用 \texttt{j}/\texttt{k} --- 那么 Vim 就会忽略回绕的部分, 而直接把光标移动到
下/上 一个真正的行上面. 如果用户不太喜欢这种行为, 也可以通过一个小技巧来解决该
问题.

假如用户希望在按住 \key{Alt} 的同时, 再用方向键 上/下 来移动光标, 那么 Vim 
就应该按照视觉上的行 --- 而不是实际的行 --- 来响应. 为了完成这样的效果, 需要在
文件 \texttt{vimrc} 中添加几行按键映射:
\begin{vimcmd}
map <A-DOWN> gj
map <A-UP> gk
imap <A-UP> <ESC>gki
imap <A-DOWN> <ESC>gji
\end{vimcmd}

映射只能在普通模式与插入模式下使用. 如果用户希望在没有按住 \key{Alt} 的情况下
也能正常工作, 只需要删除掉按键组合中的 \texttt{A-} 部分即可 (例如把第一条命令
改成 \texttt{map <DOWN> gj}).
\marginpar{60}
