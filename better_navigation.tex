% vim: ts=4 sts=4 sw=4 et tw=80
\chapter{更好的导航}
\label{chap:better_navigation}
\marginpar{53}
同时应付多个文件可能是一件非常麻烦的事, 有时候, 用户可能会花更多的时间来
定位文件, 而不是编辑.

Vim 的处世哲学是不浪费用户的宝贵时间, 所以它提供了许多用于定位文件的方法.

在这一章, 我们将会学习到 Vim 如何帮助我们在多个文件中导航, 无论此时是在
处理 1 个文件, 还是 50 个文件. 其中的某些方法使用标记, 以便于稍后返回到该
区域, 还有些方法使用搜索来定位目标.

这一章包含的内容有:
\begin{itemize}
    \item 在单个文件中更快地导航
    \item 在 Vim 帮助系统中更快地导航
    \item 在多个缓冲区更快地导航
    \item 使用 Vim 文件浏览器, 以便更快地搜索文件
    \item 文件内搜索
    \item 使用 \texttt{vimgrep} 在多个文件或多个缓冲区中搜索
    \item 使用标记作为导航的工具
    \item 使用符号来得到更好的概览
\end{itemize}

学习后这一章之后, 用户的导航速度将会有质的提升, 在搜索文件时也不会再遇到
什么问题.
\marginpar{54}
\section{在文件内更快地导航}
\label{sec:faster_navigation_in_a_file}

有时候, 即使是一件最简单的工作 --- 比如在一个单独的文件中导航 --- 也有优化
的空间. Vim 提供了几种在文件内导航的方法, 这些方法可以根据文件的内容和组织
结构而加以调整. 其中有些方法非常简单, 而另外一些则比较复杂.

\subsection{基于上下文的导航}
\label{subsec:context_aware_navigation}

在大部分情况下, 正在编辑的文件是有结构的. 如果是普通的文本文件, 那么文件的结
构可以是段落, 语句, 单词, 在另外的一些场合中, 还有可能是函数, 代码块和代码
行.

Vim 支持根据文件的结构, 在文件中跳转. 它还提供了一些按键绑定, 从而可以更
方便地跳转到某个特定的位置上.

让我们来看一些例子:
\begin{itemize}
    \item 在普通的文本文件中移动
    \item 在代码文件中移动
\end{itemize}

\subsubsection{在普通的文本文件中移动}
\label{subsubsec:moving_around_within_a_text_file}

假设用户正在编辑一个普通文件文件, 此时光标正停留在一个句子的中部, 而用户
突然意识到自己忘了把本段的第一个字母大写. 虽然用户可以通过方向键, 或
\texttt{h}, \texttt{j}, \texttt{k}, \texttt{l}, 把光标移到段落的首字母. 然而, 在普通 
模式下, 直接按下面这个按键可以得到更好的效果:
\begin{vimcmd}
{
\end{vimcmd}

按完这个按键之后, 光标已经停在了段落的开头, 或者是段落正上方的空行 (如果 
有的话). 现在, 用户可以通过按下 \key{Esc} 进入到普通模式, 再按 \texttt{\{},
把光标移到段落的开始. 与此类似, 用户只要按下和 \texttt{\{} 相对的按键, 即:
\begin{vimcmd}
}
\end{vimcmd}
就可以把光标移到段落的末尾.

也许用户并不是在段落的末尾工作, 而是在修改段落中的某些错误. Vim 可以记住
用户之前修改过的地方 (实际上, Vim 可以记住最近 999 个被修改过的地方), 因此
用户可以通过询问这些信息, 从而回到正确的地点. 在普通模式下执行下面这个命令:
\begin{vimcmd}
g,
\end{vimcmd}
\marginpar{55}
执行该命令几次, 就可以遍历之前修改过的地方. 和 \texttt{\{} 一样, 它也有一个相反
的命令, 用于反向遍历之前修改过的地方, 这个命令是
\begin{vimcmd}
g;
\end{vimcmd}
如果没有更多的地方可供遍历, Vim 就会发出一个警告.

还有一种情况是, 用户并不是在段落的开头忘记了大写字母, 而是在句子的开头, 对此,
Vim 也提供了一对命令, 用来把光标移到句子的开始与末尾, 这对命令是:
\begin{itemize}
    \item \texttt{(}: 移到句子的开头
    \item \texttt{)}: 移到句子的末尾
\end{itemize}

Vim 不希望用户在移动光标上花费太多的时间, 虽然用户可以通过方向键来遍历字母, 从
而在单词间移动, 但是 Vim 还是认为这太浪费按键了. Vim 提供了一组命令, 用于在单词
间移动, 比如:
\begin{itemize}
    \item \texttt{w}: 移到下一个单词的首字母
    \item \texttt{b}: 移到前一个单词的首字母
    \item \texttt{e}: 移到单词的末尾
\end{itemize}
这些命令可以互相组合, 比如, 用户想要移到下一个单词的末尾, 只需要执行:
\begin{vimcmd}
we
\end{vimcmd}

对于单词的定义, Vim 有两套标准:
\begin{itemize}
    \item 一个 word 由字母, 数字, 破折号, 下划线组成
    \item 一个 WORD 由非空白字符 (除了制表符与空格) 组成
\end{itemize}
前面提到的命令用于 word, 当然, WORD 也会有相应的命令, 只不过使用的是大写形式
(比如用 \texttt{W} 移到下一个 WORD 的首字母).
\marginpar{56}
\begin{warning}
    如果读者希望在一行内多次执行本小节中提到的命令, 只需要在执行命令前加上一个
    数字即可, 这个数字表示命令执行的次数. 例如, \texttt{5w} 表示光标向前移动 5
    个单词.
\end{warning}

\subsubsection{在代码文件中移动}
\label{subsubsec:moving_in_a_code_file}

和普通文本文件相比, 代码文件并没有段落或句子上的概念, 它包含的是大量的结构和块,
其中每一个结构或块都有特定的上下文含义. 一个简单的例子是:
\begin{verbatim}
    if (a == b)
    {
        print "a and b are the same"
    }
\end{verbatim}
代码中, 带有 \texttt{print} 的行在 \texttt{if} 块的上下文环境中.

因为 Vim 深受众多程序员的喜爱, 所以它提供了许多在代码中移动的命令. Common for
all of them is that the parts of the code you want to jump between need to have
a contextual connection to each other.\footnote{TODO}

一个简单的例子可以是 C 语言中的 \texttt{\#if}-\texttt{\#else}-\texttt{\#endif}
代码块, 这三个元素分别处于代码块的开始, 中间, 和结束.

如果用户此时正位于 \texttt{\#if} 所在的行, 执行命令:
\begin{vimcmd}
%
\end{vimcmd}
就可以跳转到 \texttt{\#else} 所在的行, 此时再按一次 \verb'%', 又会跳转到
\texttt{\#endif} 所在的行, 再按一次 \verb'%' 就会回到最初的 \texttt{\#if}.

Vim 无法识别所有的编程语言的构造, 不过在默认情况下, 它可以识别 C 语言的大部分
结构. 除此之外, 它还可以识别出大部分编程语言的普通代码块 --- 代码块通过圆括号
与花括号定界 (例如, \verb'{' 标出了块的开始, 而 \verb'}' 则表示块的结束).
\marginpar{57}
